#define F_CPU 16000000UL
#include <avr/io.h>
#include <util/delay.h>
#include <stdlib.h>
#include <stdio.h>
#include <avr/interrupt.h>
#include "uart_printf.h"

volatile unsigned long __millis = 0;

// ---------------- Motor Control ----------------
void motor_cw(uint8_t pwm_val) {
	PORTC |=  (1 << PC4);
	PORTC &= ~(1 << PC5);
	OCR0A = pwm_val;
}

void motor_ccw(uint8_t pwm_val) {
	PORTC &= ~(1 << PC4);
	PORTC |=  (1 << PC5);
	OCR0A = pwm_val;
}

void motor_stop(void) {
	PORTC &= ~((1 << PC4) | (1 << PC5));
	OCR0A = 0;
}

// ---------------- PWM setup ----------------
void PWM0_init(void) {
	DDRD |= (1 << PD6);               // PD6 (OC0A) as output
	DDRC |= (1 << PC4) | (1 << PC5);  // Motor direction pins

	TCCR0A = (1 << WGM01) | (1 << WGM00); // Fast PWM
	TCCR0A |= (1 << COM0A1);              // Non-inverting mode
	TCCR0B = (1 << CS01) | (1 << CS00);   // Prescaler = 64
	OCR0A = 0;
}

// ---------------- ADC setup ----------------
void ADC_init(void) {
	ADMUX = (1 << REFS0);                   // AVcc reference, ADC0
	ADCSRA = (1 << ADEN) |
	(1 << ADPS2) | (1 << ADPS1) | (1 << ADPS0); // prescaler 128
}

uint16_t get_adc(void) {
	ADCSRA |= (1 << ADSC);          // Start conversion
	while (ADCSRA & (1 << ADSC));   // Wait
	return ADC;                     // Return 10-bit value
}

// ---------------- UART input ----------------
uint8_t USART_available(void) {
	return (UCSR0A & (1 << RXC0));
}

char USART_receive(void) {
	return UDR0;
}

// ---------------- Timer2 setup for 1ms ----------------
void Timer2_init(void) {
	TCCR2A = (1 << WGM21);   // CTC mode
	TCCR2B = (1 << CS22);    // Prescaler = 64
	OCR2A = 249;             // (16MHz / 64 / 1000Hz) - 1 = 249
	TIMSK2 = (1 << OCIE2A);  // Enable compare interrupt
	sei();                   // Enable global interrupt
}

ISR(TIMER2_COMPA_vect) {
	__millis++;
}

// ---------------- MAIN ----------------
int main(void) {
	init_usart_printf(115200);
	UCSR0B |= (1 << RXEN0) | (1 << TXEN0); // Enable RX and TX

	PWM0_init();
	ADC_init();
	Timer2_init();

	int16_t ref = 300;
	float gain = 5.0;
	unsigned long last_toggle = 0;

	printf("Motor Control Ready\n");
	printf("Auto toggle ref every 500 ms\n");

	while (1) {
		// ---- Auto toggle ref every 500ms ----
		if (__millis - last_toggle >= 500) {
			if (ref == 300) ref = 700;
			else ref = 300;
			last_toggle = __millis;
		}

		// ---- UART override (optional) ----
		if (USART_available()) {
			char key = USART_receive();
			if (key == '+') gain += 1.0;
			else if (key == '-') gain -= 1.0;
		}

		// ---- Read ADC ----
		uint16_t adc_val = get_adc();
		int16_t error_raw = ref - adc_val;

		// ---- P control ----
		float pControl = gain * ((float)error_raw / 1024.0);
		int16_t motorPWM = (int16_t)(pControl * 255);

		if (motorPWM > 255) motorPWM = 255;
		if (motorPWM < -255) motorPWM = -255;

		if (motorPWM > 0) motor_ccw(motorPWM);
		else if (motorPWM < 0) motor_cw(-motorPWM);
		else motor_stop();

		// ---- Debug info ----
		printf("millis=%lu, ref=%d, adc=%d, error=%d, gain=%.1f\n",
		       __millis, ref, adc_val, error_raw, gain);
	}
}
